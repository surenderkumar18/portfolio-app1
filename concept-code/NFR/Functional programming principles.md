# Immutability:

In functional programming, data is immutable, meaning once it is created, it cannot be changed. Instead of modifying existing data, functional programs create new data structures with the desired changes.

# Pure Functions:

A pure function is a function that produces the same output for the same input and has no side effects. It does not modify external state or rely on external state. Pure functions are deterministic, making them easier to reason about and test.

# First-Class and Higher-Order Functions:

In functional programming languages, functions are first-class citizens, which means they can be assigned to variables, passed as arguments to other functions, and returned from other functions. Higher-order functions are functions that take other functions as arguments or return them as results.

# Referential Transparency:

A function is referentially transparent if it can be replaced with its corresponding value without changing the program's behavior. This property allows for equational reasoning and enables optimization opportunities.

# Avoiding Side Effects:

Side effects occur when a function modifies state outside of its scope, such as mutating variables, performing I/O operations, or interacting with external systems. Functional programming seeks to minimize side effects and isolate them when necessary.

# Recursion:

Recursion is a fundamental concept in functional programming, where functions call themselves to solve problems by breaking them down into smaller, similar sub-problems. Recursive algorithms are often used to traverse data structures and perform computations.

# Functional Composition:

Functional composition involves combining multiple functions to create new functions. Composition allows for the creation of complex behavior by chaining together simpler functions, promoting code reuse and modularity.

# Declarative Programming:

Functional programming emphasizes declarative programming styles, where programs describe what should be done rather than how to do it. Declarative code is often more concise, readable, and maintainable than imperative code.
